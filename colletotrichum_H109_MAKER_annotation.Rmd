---
title: "Colletotrichum_H109_MAKER_annotation"
author: "Emily Giroux"
date: "6/11/2019"
output: pdf_document
fontsize: 11pt
geometry: margin=1in
urlcolor: blue
header-includes: \usepackage{xcolor}
---
```{r, global_options, eval=TRUE, echo=FALSE, cache=TRUE}
#Set the global options for knitr
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=80), tidy = TRUE, fig.align='center',
               cache=FALSE, collapse=TRUE, echo=FALSE, eval=FALSE, include=FALSE,
               message=FALSE, quietly=TRUE, results='hide', warn.conflicts=FALSE, 
               warning=FALSE)
```

```{r, installation1, eval=TRUE, echo=FALSE, include=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
#Installing required packages
r = getOption("repos")
r["CRAN"] = "http://cran.us.r-project.org"
options(repos = r)

if(!require(devtools)) install.packages("devtools")
devtools::install_github("kassambara/fastqcr")

if (!requireNamespace("BiocManager"))
    install.packages("BiocManager")
BiocManager::install()

library("BiocManager")
.cran_packages <- c("data.table", "dplyr", "filesstrings", 
                    "ggplot2", "gridExtra", "kableExtra", 
                    "knitr", "reshape2", "rprojroot",    
                    "R.utils", "tidyr")
.bioc_packages <- c("BiocStyle", "Biostrings")
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  BiocManager::install(.bioc_packages[!.inst], ask = FALSE)
}
sapply(c(.cran_packages, .bioc_packages), require, character.only = TRUE)
```

```{r sourcing_my_functions, echo=FALSE, eval=TRUE, include=FALSE, cache=TRUE}
#Source our custom R scripts:    
#For this we will use the rprojroot package to set the directory structures. This will help us when finding our files to source functions. We specify ours is an RStudio project. The root object contains a function that will help us locate our package R files regarless of our current working directory.
library(rprojroot)
root <- rprojroot::is_rstudio_project
scriptsPath <- root$make_fix_file(".")("R")
scripts  <- dir(root$find_file("R", path = root$find_file()))
scriptsl <- paste(scriptsPath, scripts, sep = "//")
lapply(scriptsl, source)
# Record the path to the environment images directory:
sharedPath <- "/isilon/cfia-ottawa-fallowfield/users/girouxeml/PIRL_working_directory"
analysis   <- "colletotrichum_H109_annotation"
sharedPathAn <- paste(sharedPath, analysis, sep = "/")

imageDirPath <- "/isilon/cfia-ottawa-fallowfield/users/girouxeml/GitHub_Repos/r_environments/colletotrichum_H109_annotation/"
baseImage    <- "colletotrichum_H109_annotation_June2019.RData"

load(paste(imageDirPath, baseImage, sep = ""))

save.image(paste(imageDirPath, baseImage, sep = ""))
load(paste(imageDirPath, baseImage, sep = ""))
```
     
     
Note: Annotation begins with using RepeatModeler and then RepeatMasker to model and mask repetitive content. A problem with the installation is preventing successfull modelling. Solution is to create a conda environment for RepeatModeler.     
$ /home/CFIA-ACIA/girouxeml/prog/miniconda/envs/repeats/bin     
     
**Read in the metadata table:**  
We need to specify where we put the assembly files for our genomes. We had this in our metadataAssembly table 
from our previous script we ran called "RstudioScript-June2017_LachnellulaSpp_assemblies.Rmd"
We can either read in the table, or take what we have from the environment. Reading in the table is better.
```{r}
library(data.table)
colletotrichumAssemblyDir <- "/isilon/cfia-ottawa-fallowfield/users/girouxeml/PIRL_working_directory/colletotrichum"
metadataFile <- "colleto_ionT_2018_1_metadata_Assembly_Oct2018.csv"

metadata <- fread(paste(colletotrichumAssemblyDir, metadataFile, sep = "/"), sep = "auto", header = TRUE)
metadata[, V1:=NULL]
# Realised that the isolate name is not included in my csv - so adding it now, and making a shortname for it.
metadata$isolate <- "H109"
metadata$shortname <- paste(metadata$SppAbbr, metadata$isolate, sep = "_")
```
Copy the assembly file into the references directory, and change the suffix to ".fasta", instead of ".fna" - repeatMasker only works with ".fa" or ".fasta" suffixes.
```{r}
dir.create(paste(referencesPath, "colletotrichum", sep = "/"),
           showWarnings = TRUE, recursive = FALSE)
refPath <- paste(referencesPath, "colletotrichum", sep = "/")
file.copy(metadata$FixedNewAssemName, 
          paste(referencesPath, 
                "colletotrichum/colleto_assembly_largeContigs.fixedNames.fasta", sep = "/"), 
          recursive = FALSE)
metadata$assembly <- paste(refPath, "colleto_assembly_largeContigs.fixedNames.fasta", sep = "/")
```


### 1. De novo Repeat Identification.  
The first, and very important, step to genome annotation is identifying repetitive content. Existing libraries 
from Repbase or from internal efforts are great, but it is also important to identify repeats de novo from your reference 
genome using RepeatModeler. This is pretty easy to do and normally only takes a couple days using 8-12 cores.  
Why do this? 
If we were working with a well-studied organism, we wouldn't need to, we could just stick to the database that repeatmasker 
used which we updated with RepBase. But our species are not well-studied, and so we need to create 
a species-specific repeat library for it.     
     
**Note:**     
Remember to use the modified assemblies that have the extra details that Newbler added after the >contig 
name (3 tabs for contig name, length and some other detail) removed because this info created problems downstream.     
    
#### 1-A. Setting up directories.
**Make a directory within a species-specific directory that will contain all Repeat and MAKER annotation data:**
```{r}
# Create directory for H109 isolate:
dir.create(paste(sharedPathAn, metadata$shortname, sep = "/"),
           showWarnings = TRUE, recursive = FALSE)

# Create repeat directory and add name to metadata:
dir.create(paste(sharedPathAn, metadata$shortname, "RepeatDB", sep = "/"),
           showWarnings = TRUE, recursive = FALSE)
metadata$RepeatDB <- paste(sharedPathAn, metadata$shortname, "RepeatDB", sep = "/")
```

#### 1-B. Build a repeat database for RepeatModeler for each species.
```{r}
prefix <- "buildDB"
cmd <- paste("cd ", metadata$RepeatDB, "/", " && ", repModBuildDBPath, " -name ", metadata$shortname, 
             " ", metadata$assembly, sep = "")
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Run RepeatModeler using the databases just made for each species:**      
**Note:** if there is an unexpected system failure, RepeatModeler can recover from it and continue from where it
previously left off. See the README file in its program directory.

```{r}
node   <- 6
prefix <- "repeatModeler"
cmd <- paste("cd ", metadata$RepeatDB, " && ", repModlerPath, " -pa ", node, 
             " -database ", metadata$shortname, " 2>&1 | tee repeatmodeler.log ", sep = "")
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```

```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

RepeatModeler recovery bash in case of run failure:     
    If for some reason RepeatModeler fails, you may restart an
    analysis starting from the last round it was working on.  The
    -recoverDir [<i>ResultDir</i>] option allows you to specify a
    diretory ( i.e RM_<PID>.<DATE>/ ) where a previous run of
    RepeatModeler was working and it will automatically determine
    how to continue the analysis.
```{r}
node   <- 6
lastRM_dir <- "RM_18979.FriJun141042152019"
prefix <- "repeatModeler_Recovery"
cmd <- paste("cd ", metadata$RepeatDB, " && ", repModlerPath, " -pa ", node, 
             " -database ", metadata$shortname, 
             " -recoverDir ", paste(metadata$RepeatDB, lastRM_dir, sep = "/"),
             " 2>&1 | tee repeatmodeler.Recovery.log ", sep = "")
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```

The next step is to remove the huge temp directories for each round, withing the repeat modeler directory. Then copy the consensi files to the parent directorycopy all the consensi.fa.classified libraries to a directory and combine them, then separate 
fasta entries with known and unknown repeats.  
```{r}
metadata$repModelerDir <- list.files(path = metadata$RepeatDB, pattern = "^RM_.*")
metadata$repModlDirPath <- paste(metadata$RepeatDB, metadata$repModelerDir, sep = "/")
tmp <- list.files(path = metadata$repModlDirPath, pattern = "^roun.*")
unlink(paste(metadata$repModlDirPath, tmp, sep = "/"),
       recursive = TRUE)
list.files(path = metadata$repModlDirPath)
```
**Split unknown and known repeats to separate files:**     
We'll use perl scripts for this (in ~/prog/scripts_pl/): _selectFasta_byIDUnknown.pl_, _selectFasta_byID_Known.pl_     
     
**Note:** You need run the generated perl scripts in the directory where your input is.
```{r}
# Must specifiy path to the directory and save to this variable since it's used in the function:
allSppRepeatDBpath <- metadata$repModlDirPath
# Write script to parse and get all repeats that are "Known"
identity <- 1
infile   <- paste(metadata$repModlDirPath, "consensi.fa.classified", sep = "/")
parseFastaByHeaderPattern(infile, identity)

# Repeat the above with identity <- 2, to get all the unknown fastas:
identity <- 2
infile   <- paste(metadata$repModlDirPath, "consensi.fa.classified", sep = "/")
parseFastaByHeaderPattern(infile, identity)
```

#### 1-C. Quality check of the repeat database built with RepeatModeler.     
QC the output from the Unknown_consensi.fa.classified repeat library to check for repeats that 
are really genes (gene families) or RNA features:     
     
**Blastx vs nr:**       
I did this one on the command line. Blastx vs nr for protein coding genes (I qlogin'd with 22 processors, so thread using 21):     
```{bash}  
$ blastx -db /isilon/ottawa-rdc/reference/ncbi/blastdb/reference/nr/nr -query Unknown_consensi.fa.classified -evalue 10e-5 -num_alignments 5 -num_threads 21 > Unknown_consensi.fa.classified.nrcheck.blast.out_**  
```
To look at the output, search for "Sequences producing significant alignments".  

**Blastn vs RNA database for ribosomal or other RNA genes:**  
Blastn vs RNA database for ribosomal or other RNA genes. Rfam.fasta comes with the Rfam download and it requires you to
download the Rfam database. Do this only when it hasn't already been done, or if it's been a really
long time and you need to update the database:   
  
**_$ cd ~/prog/_**  
**_$ mkdir rfam_**  
**_$ cd rfam_**  
**_$ wget -r_ ftp://ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/fasta_files/**  
**_$ mv -f_ ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/fasta_files/\* .**  
**_$ gunzip RF0\*_**  
**_$ cat *.fa > rfam.fasta_**  
**_$ mv RF\*_ ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/fasta_files/**  
**_$ makeblastdb -in rfam.fasta -dbtype nucl_**    

**Run Blastn against the rfam database:**
```{r}
prefix <- "RepeatDB_blastn"
cmd    <- paste("blastn -db /home/CFIA-ACIA/girouxeml/prog/rfam/rfam.fasta -query ",
                paste(allSppRepeatDBpath, "Unknown_consensi.fa.classified", sep = "/"),
                " -evalue 10e-5 -num_alignments 5 -num_threads 20 > ",
                paste(allSppRepeatDBpath, "Unknown_consensi.fa.classified.rnacheck.blast.out", sep = "/"),
                sep = "")
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

Look at the output from the Blastx and Blastn runs, and remove repeats that are actually really genes (gene families) or RNA features from the Unknown consensi classified repeat file.     
The final unknown file is called "Unknown_consensi.fa.nr.rna.checked.blast.classified" and the known repeat library file
is called "Known_consensi.fa.classified".     

**Convert the EMBL repeat library from RepeatMasker to fasta format:**  
Place the embl repeat library in its own dir:
```{r}
dir.create(paste(metadata$RepeatDB, "embl_RepeatMaskerDB", sep = "/"), showWarnings = TRUE, recursive = FALSE)
prefix <- "embl_buildRepMaskeLib"
cmd    <- paste("buildRMLibFromEMBL.pl ", emblDBRepMasker, " ",
                paste(allSppRepeatDBpath, "Known_consensi.fa.classified", sep = "/"),
                " ", paste(allSppRepeatDBpath, "Unknown_consensi.fa.nr.rna.checked.blast.classified", sep = "/"),
                " > ", paste(metadata$RepeatDB, "embl_RepeatMaskerDB/RepeatMaskerLib.fasta", sep = "/"),
                sep = "")
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
Further steps can be taken to annotate the resulting library, but the most important reason for this library is for downstream gene prediction. This step came from an example where a Boa library was combined with several other snakes and annotated:      
      
https://gist.github.com/darencard/bb1001ac1532dd4225b030cf0cd61ce2       
     
#### 1-D. Full Repeat Annotation with RepeatMasker:     
    
**Full Repeat Annotation:**     
Depending on the species, the de novo library can be fed right into MAKER, however, based on the very thorough example provided 
by https://gist.github.com/darencard/bb1001ac1532dd4225b030cf0cd61ce2, we'll be doing a more complex repeat identification.
  
**EMBL repeat library masking:**    
First, we mask using a currated library to overcome a previously-identified issue with the Repbase annotation. 
I used the known library from repeatmasker.lib.EMBL, which I converted to fasta format using RepeatMasker/util/buildRMLibFromEMBL.pl script.
Then we pass the species genome assemblies through the RepeatMaskerLib.fasta using RepeatMasker.
```{r}
dir.create(paste(metadata$RepeatDB, "embl_mask", sep = "/"), showWarnings = TRUE, recursive = FALSE)
metadata$emblMaskPath <- paste(metadata$RepeatDB, "embl_mask", sep = "/")
prefix <- "embl_mask"
node   <- 12
cmd <- paste("cd ", metadata$emblMaskPath, " && RepeatMasker ", 
             " -pa ", node, 
             " -lib ", paste(metadata$RepeatDB, "embl_RepeatMaskerDB/RepeatMaskerLib.fasta", sep = "/"),
             " -dir . ", metadata$assembly, sep = "")
cmd
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
**Known repeat library masking:**     
Then the masked FASTA from this search can be used as input for the next search. I also normally 
rename the outputs after each round so they are more representative of what they contain. Do 2 rounds, 
using the known and unknown repeat libraries created, split, so that the known elements 
would be preferentially annotated over unknown, to the degree possible.  
```{r}
dir.create(paste(metadata$RepeatDB, "Known_Mask", sep = "/"), showWarnings = TRUE, recursive = FALSE)
metadata$KnownMaskPath <- paste(metadata$RepeatDB, "Known_Mask", sep = "/")

# Run RepeatMasker with known repeat lib 1st, using as input the embl masked output
prefix <- "Known_Mask"
node   <- 12

cmd <- paste("cd ", metadata$KnownMaskPath, " && RepeatMasker ", 
             " -pa ", node, 
             " -lib ", paste(metadata$repModlDirPath, "Known_consensi.fa.classified", sep = "/"),
             " -dir . ", paste(metadata$emblMaskPath, "*.fasta.masked", sep = "/"),
             sep = "")
cmd
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Unknown repeat library masking:**    
Run RepeatMasker with unknown repeat lib, using as input the unknown masked output. Note, make sure to use the unknown lib
that was passed through NR, RNA, and BLAST checks to remove repeats that were actually part of genes or functional RNAs.
```{r}
dir.create(paste(metadata$RepeatDB, "Unknown_Mask", sep = "/"), showWarnings = TRUE, recursive = FALSE)
metadata$UnknownMaskPath <- paste(metadata$RepeatDB, "Unknown_Mask", sep = "/")

# Run RepeatMasker with unknown repeat lib 2nd, using as input the Known masked output
prefix <- "Unknown_Mask"
node   <- 12

cmd <- paste("cd ", metadata$UnknownMaskPath, " && RepeatMasker ", 
             " -pa ", node, 
             " -lib ", paste(metadata$repModlDirPath, "Unknown_consensi.fa.nr.rna.checked.blast.classified", sep = "/"),
             " -dir . ", paste(metadata$KnownMaskPath, "*.fasta.masked.masked", sep = "/"),
             sep = "")
cmd
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
# Ignore the segmentation fault errors, these are tries over already masked strings
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Finally, results from each round must be analyzed together to produce the final repeat annotation:**
```{r}
dir.create(paste(metadata$RepeatDB, "Full_mask", sep = "/"), showWarnings = TRUE, recursive = FALSE)
file.copy(paste(metadata$UnknownMaskPath, 
                "colleto_assembly_largeContigs.fixedNames.fasta.masked.masked.masked", sep = "/"),
          paste(metadata$RepeatDB, "/Full_mask/", metadata$shortname, ".assembly.full_mask.fa", sep = ""))
          
list.files(paste(metadata$RepeatDB, "Full_mask", sep = "/"))

file.copy(paste(metadata$UnknownMaskPath, 
                "colleto_assembly_largeContigs.fixedNames.fasta.masked.masked.out", sep = "/"),
          paste(metadata$RepeatDB, "/Full_mask/", metadata$shortname, ".assembly.full_mask.out", sep = ""))
          
list.files(paste(metadata$RepeatDB, "Full_mask", sep = "/"))
```

**Gunzip and then cat repeat outputs:**
```{r}
library("R.utils")
gunzip(paste(metadata$emblMaskPath, "colleto_assembly_largeContigs.fixedNames.fasta.cat.gz", sep = "/"))
gunzip(paste(metadata$KnownMaskPath, "colleto_assembly_largeContigs.fixedNames.fasta.masked.cat.gz", sep = "/"))
gunzip(paste(metadata$UnknownMaskPath, "colleto_assembly_largeContigs.fixedNames.fasta.masked.masked.cat.gz", sep = "/"))
```

**Make a directory in each species dir for the final repeats masked:**
```{r}
dir.create(paste(metadata$RepeatDB, "Final_mask", sep = "/"), showWarnings = TRUE, recursive = FALSE)
prefix <- "catRepeatFasta"
cmd    <- paste("cat ", paste(metadata$RepeatDB, "embl_mask/*.cat ", sep = "/"),
                paste(metadata$RepeatDB, "Known_Mask/*.cat ", sep = "/"),
                paste(metadata$RepeatDB, "Unknown_Mask/*.cat ", sep = "/"),
                " > ", paste(metadata$RepeatDB, "/Final_mask/", metadata$shortname, ".assembly.full_mask.cat", sep = ""),
                sep = "")
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Process the repeats:**
```{r}
prefix <- "processRepeats"
cmd    <- with(metadata, 
               paste("ProcessRepeats -species fungi ",
                     paste(RepeatDB, "Final_mask/*.full_mask.cat ", sep = "/"), sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

Finally, in order to feed these repeats into MAKER properly, we must separate out the complex repeats (more info on this below).  
**Create GFF3:**
```{r}
prefix <- "rmOutToGFF3"
cmd    <- with(metadata, 
               paste("rmOutToGFF3.pl ", 
                     paste(RepeatDB, "Final_mask/*.full_mask.out ", sep = "/"),
                     " > ", paste(RepeatDB, "/Final_mask/", shortname, ".assembly.full_mask.out.gff3", sep = ""), 
                     sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Isolate complex repeats:**
```{r}
prefix <- "isolate_complex_Repeats"
cmd    <- with(metadata, 
               paste('grep -v -e "Satellite" -e ")n" -e "-rich"',
                     " ", paste(RepeatDB, "/Final_mask/", shortname, ".assembly.full_mask.out.gff3", sep = ""),
                     " > ", paste(RepeatDB, "/Final_mask/", shortname, ".assembly.full_mask.complex.gff3", sep = ""),
                     sep = ""))
            
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Reformat to work with MAKER:**   
**Note:**  
I can't seem to be able to generate the commands I want for this one. The commands are in the chunk below, and 
I passed them on the terminal in each directory manually.
```{r}
cmd <- with(metadata,
            paste("cat ", paste(RepeatDB, "/Final_mask/", shortname, ".assembly.full_mask.complex.gff3 ", sep = ""),
                  " | ",
                  cat(paste("perl -ane '$id; if(!/^\\#/){@F = split(/\\t/, $_); chomp $F[-1];$id++; $F[-1] .= \"\\;ID=$id\"; $_ = join(\"\\t\", @F).\"\\n\"} print $_' ")),
                  " > ",
                  paste(RepeatDB, "Final_mask/", shortname, ".assembly.full_mask.complex.reformat.gff3 ", sep = ""),
                  sep =""))
# cat /isilon/cfia-ottawa-fallowfield/users/girouxeml/PIRL_working_directory/colletotrichum_H109_annotation/colleto_H109/RepeatDB/Final_mask/colleto_H109.assembly.full_mask.complex.gff3 | \
#  perl -ane '$id; if(!/^\#/){@F = split(/\t/, $_); chomp $F[-1];$id++; $F[-1] .= "\;ID=$id"; $_ = join("\t", @F)."\n"} print $_' \
#  > /isilon/cfia-ottawa-fallowfield/users/girouxeml/PIRL_working_directory/colletotrichum_H109_annotation/colleto_H109/RepeatDB/Final_mask/colleto_H109.assembly.full_mask.complex.reformat.gff3
```
cat Fus3.assembly.full_mask.complex.gff3 | \\  
perl -ane '$id; if(!/^\#/){@F = split(/\t/, $_); chomp $F[-1];$id++; $F[-1] .= "\;ID=$id"; $_ = join("\t", @F)."\n"} print $_' \  
\> Fus3.assembly.full_mask.complex.reformat.gff3  
Now we have the prerequisite data for running MAKER. Add this to the data table:
```{r}
metadata$makerFullMaskGFF3 <- paste(metadata$RepeatDB, "/Final_mask/",
                                    metadata$shortname, ".assembly.full_mask.complex.reformat.gff3", 
                                    sep = "")
```


While RepeatModeler is running, also run Genemark-es.     
     
### Annotation using Genemark-ES.  
Before we run MAKER, we can run Genemark-es, which requires no other input but the genome assemblies. This is supposed to be especially 
useful for fungal genomes. Once this is running, you can continue on with the chunk that gets the initial run of MAKER going, since it doesn't
depend on the genemark-es outputs for the first round of MAKER.  
It's a bit tricky to install the genemark-es due to dependencies, but works by installing one at a time all
dependencies using **cpanm**. Also, there was an error when trying to run it at first:  
  
/usr/bin/perl: symbol lookup error: /home/CFIA-ACIA/girouxeml/perl5/lib/perl5/x86_64-linux-thread-multi/auto/List/Util/Util.so: undefined symbol: Perl_xs_apiversion_bootcheck  
  
The fix was to remove the directory in _**~/perl5/lib/perl5/x86_64-linux-thread-multi/auto/List/Util/**_ and just 
placing it in my home directory (or if you want you can just delete it too):  
  
**_$ cd ~/perl5/lib/perl5/_**  
**_$ mv -f x86_64-linux-thread-multi_** **~**  
  
See: https://www.reddit.com/r/openbsd/comments/65efvo/openbsd_61_perl_problem_undefined_symbol_perl_xs/  
  

#### A. Setting up paths to run Genemark-es in the species-specific directory:
```{r}
metadata$genemarkEs <- paste(sharedPathAn, metadata$shortname, "genemark-es", sep = "/")
dir.create(metadata$genemarkEs, showWarnings = TRUE, recursive = FALSE)
```

#### B. Create and submit the Qsub to run Genemark-es:
```{r}
prefix <- "genemark-ES"
node   <- 8
cmd <- paste("cd ", metadata$genemarkEs, " && ",
             " perl ", genemarkPath, " --ES --fungus --cores ", node, " --v ",
             " --sequence ", metadata$assembly, sep = "")
cmd
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```











